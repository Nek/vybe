// Generated by jextract

package org.vybe.jolt;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct JPC_CharacterVirtualSettings {
 *     JPC_CharacterBaseSettings base;
 *     float mass;
 *     float max_strength;
 *     float shape_offset[4];
 *     JPC_BackFaceMode back_face_mode;
 *     float predictive_contact_distance;
 *     uint32_t max_collision_iterations;
 *     uint32_t max_constraint_iterations;
 *     float min_time_remaining;
 *     float collision_tolerance;
 *     float character_padding;
 *     uint32_t max_num_hits;
 *     float hit_reduction_cos_max_angle;
 *     float penetration_recovery_speed;
 * }
 * }
 */
public class JPC_CharacterVirtualSettings {

    JPC_CharacterVirtualSettings() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        JPC_CharacterBaseSettings.layout().withName("base"),
        jolt.C_FLOAT.withName("mass"),
        jolt.C_FLOAT.withName("max_strength"),
        MemoryLayout.paddingLayout(8),
        MemoryLayout.sequenceLayout(4, jolt.C_FLOAT).withName("shape_offset"),
        jolt.C_CHAR.withName("back_face_mode"),
        MemoryLayout.paddingLayout(3),
        jolt.C_FLOAT.withName("predictive_contact_distance"),
        jolt.C_INT.withName("max_collision_iterations"),
        jolt.C_INT.withName("max_constraint_iterations"),
        jolt.C_FLOAT.withName("min_time_remaining"),
        jolt.C_FLOAT.withName("collision_tolerance"),
        jolt.C_FLOAT.withName("character_padding"),
        jolt.C_INT.withName("max_num_hits"),
        jolt.C_FLOAT.withName("hit_reduction_cos_max_angle"),
        jolt.C_FLOAT.withName("penetration_recovery_speed"),
        MemoryLayout.paddingLayout(8)
    ).withName("JPC_CharacterVirtualSettings");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout base$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("base"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPC_CharacterBaseSettings base
     * }
     */
    public static final GroupLayout base$layout() {
        return base$LAYOUT;
    }

    private static final long base$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPC_CharacterBaseSettings base
     * }
     */
    public static final long base$offset() {
        return base$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPC_CharacterBaseSettings base
     * }
     */
    public static MemorySegment base(MemorySegment struct) {
        return struct.asSlice(base$OFFSET, base$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPC_CharacterBaseSettings base
     * }
     */
    public static void base(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, base$OFFSET, base$LAYOUT.byteSize());
    }

    private static final OfFloat mass$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("mass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float mass
     * }
     */
    public static final OfFloat mass$layout() {
        return mass$LAYOUT;
    }

    private static final long mass$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float mass
     * }
     */
    public static final long mass$offset() {
        return mass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float mass
     * }
     */
    public static float mass(MemorySegment struct) {
        return struct.get(mass$LAYOUT, mass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float mass
     * }
     */
    public static void mass(MemorySegment struct, float fieldValue) {
        struct.set(mass$LAYOUT, mass$OFFSET, fieldValue);
    }

    private static final OfFloat max_strength$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("max_strength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float max_strength
     * }
     */
    public static final OfFloat max_strength$layout() {
        return max_strength$LAYOUT;
    }

    private static final long max_strength$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float max_strength
     * }
     */
    public static final long max_strength$offset() {
        return max_strength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float max_strength
     * }
     */
    public static float max_strength(MemorySegment struct) {
        return struct.get(max_strength$LAYOUT, max_strength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float max_strength
     * }
     */
    public static void max_strength(MemorySegment struct, float fieldValue) {
        struct.set(max_strength$LAYOUT, max_strength$OFFSET, fieldValue);
    }

    private static final SequenceLayout shape_offset$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("shape_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static final SequenceLayout shape_offset$layout() {
        return shape_offset$LAYOUT;
    }

    private static final long shape_offset$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static final long shape_offset$offset() {
        return shape_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static MemorySegment shape_offset(MemorySegment struct) {
        return struct.asSlice(shape_offset$OFFSET, shape_offset$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static void shape_offset(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, shape_offset$OFFSET, shape_offset$LAYOUT.byteSize());
    }

    private static long[] shape_offset$DIMS = { 4 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static long[] shape_offset$dimensions() {
        return shape_offset$DIMS;
    }
    private static final VarHandle shape_offset$ELEM_HANDLE = shape_offset$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static float shape_offset(MemorySegment struct, long index0) {
        return (float)shape_offset$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * float shape_offset[4]
     * }
     */
    public static void shape_offset(MemorySegment struct, long index0, float fieldValue) {
        shape_offset$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfByte back_face_mode$LAYOUT = (OfByte)$LAYOUT.select(groupElement("back_face_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * JPC_BackFaceMode back_face_mode
     * }
     */
    public static final OfByte back_face_mode$layout() {
        return back_face_mode$LAYOUT;
    }

    private static final long back_face_mode$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * JPC_BackFaceMode back_face_mode
     * }
     */
    public static final long back_face_mode$offset() {
        return back_face_mode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * JPC_BackFaceMode back_face_mode
     * }
     */
    public static byte back_face_mode(MemorySegment struct) {
        return struct.get(back_face_mode$LAYOUT, back_face_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * JPC_BackFaceMode back_face_mode
     * }
     */
    public static void back_face_mode(MemorySegment struct, byte fieldValue) {
        struct.set(back_face_mode$LAYOUT, back_face_mode$OFFSET, fieldValue);
    }

    private static final OfFloat predictive_contact_distance$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("predictive_contact_distance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float predictive_contact_distance
     * }
     */
    public static final OfFloat predictive_contact_distance$layout() {
        return predictive_contact_distance$LAYOUT;
    }

    private static final long predictive_contact_distance$OFFSET = 100;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float predictive_contact_distance
     * }
     */
    public static final long predictive_contact_distance$offset() {
        return predictive_contact_distance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float predictive_contact_distance
     * }
     */
    public static float predictive_contact_distance(MemorySegment struct) {
        return struct.get(predictive_contact_distance$LAYOUT, predictive_contact_distance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float predictive_contact_distance
     * }
     */
    public static void predictive_contact_distance(MemorySegment struct, float fieldValue) {
        struct.set(predictive_contact_distance$LAYOUT, predictive_contact_distance$OFFSET, fieldValue);
    }

    private static final OfInt max_collision_iterations$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_collision_iterations"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_collision_iterations
     * }
     */
    public static final OfInt max_collision_iterations$layout() {
        return max_collision_iterations$LAYOUT;
    }

    private static final long max_collision_iterations$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_collision_iterations
     * }
     */
    public static final long max_collision_iterations$offset() {
        return max_collision_iterations$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_collision_iterations
     * }
     */
    public static int max_collision_iterations(MemorySegment struct) {
        return struct.get(max_collision_iterations$LAYOUT, max_collision_iterations$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_collision_iterations
     * }
     */
    public static void max_collision_iterations(MemorySegment struct, int fieldValue) {
        struct.set(max_collision_iterations$LAYOUT, max_collision_iterations$OFFSET, fieldValue);
    }

    private static final OfInt max_constraint_iterations$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_constraint_iterations"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_constraint_iterations
     * }
     */
    public static final OfInt max_constraint_iterations$layout() {
        return max_constraint_iterations$LAYOUT;
    }

    private static final long max_constraint_iterations$OFFSET = 108;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_constraint_iterations
     * }
     */
    public static final long max_constraint_iterations$offset() {
        return max_constraint_iterations$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_constraint_iterations
     * }
     */
    public static int max_constraint_iterations(MemorySegment struct) {
        return struct.get(max_constraint_iterations$LAYOUT, max_constraint_iterations$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_constraint_iterations
     * }
     */
    public static void max_constraint_iterations(MemorySegment struct, int fieldValue) {
        struct.set(max_constraint_iterations$LAYOUT, max_constraint_iterations$OFFSET, fieldValue);
    }

    private static final OfFloat min_time_remaining$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("min_time_remaining"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float min_time_remaining
     * }
     */
    public static final OfFloat min_time_remaining$layout() {
        return min_time_remaining$LAYOUT;
    }

    private static final long min_time_remaining$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float min_time_remaining
     * }
     */
    public static final long min_time_remaining$offset() {
        return min_time_remaining$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float min_time_remaining
     * }
     */
    public static float min_time_remaining(MemorySegment struct) {
        return struct.get(min_time_remaining$LAYOUT, min_time_remaining$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float min_time_remaining
     * }
     */
    public static void min_time_remaining(MemorySegment struct, float fieldValue) {
        struct.set(min_time_remaining$LAYOUT, min_time_remaining$OFFSET, fieldValue);
    }

    private static final OfFloat collision_tolerance$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("collision_tolerance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float collision_tolerance
     * }
     */
    public static final OfFloat collision_tolerance$layout() {
        return collision_tolerance$LAYOUT;
    }

    private static final long collision_tolerance$OFFSET = 116;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float collision_tolerance
     * }
     */
    public static final long collision_tolerance$offset() {
        return collision_tolerance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float collision_tolerance
     * }
     */
    public static float collision_tolerance(MemorySegment struct) {
        return struct.get(collision_tolerance$LAYOUT, collision_tolerance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float collision_tolerance
     * }
     */
    public static void collision_tolerance(MemorySegment struct, float fieldValue) {
        struct.set(collision_tolerance$LAYOUT, collision_tolerance$OFFSET, fieldValue);
    }

    private static final OfFloat character_padding$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("character_padding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float character_padding
     * }
     */
    public static final OfFloat character_padding$layout() {
        return character_padding$LAYOUT;
    }

    private static final long character_padding$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float character_padding
     * }
     */
    public static final long character_padding$offset() {
        return character_padding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float character_padding
     * }
     */
    public static float character_padding(MemorySegment struct) {
        return struct.get(character_padding$LAYOUT, character_padding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float character_padding
     * }
     */
    public static void character_padding(MemorySegment struct, float fieldValue) {
        struct.set(character_padding$LAYOUT, character_padding$OFFSET, fieldValue);
    }

    private static final OfInt max_num_hits$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_num_hits"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_num_hits
     * }
     */
    public static final OfInt max_num_hits$layout() {
        return max_num_hits$LAYOUT;
    }

    private static final long max_num_hits$OFFSET = 124;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_num_hits
     * }
     */
    public static final long max_num_hits$offset() {
        return max_num_hits$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_num_hits
     * }
     */
    public static int max_num_hits(MemorySegment struct) {
        return struct.get(max_num_hits$LAYOUT, max_num_hits$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_num_hits
     * }
     */
    public static void max_num_hits(MemorySegment struct, int fieldValue) {
        struct.set(max_num_hits$LAYOUT, max_num_hits$OFFSET, fieldValue);
    }

    private static final OfFloat hit_reduction_cos_max_angle$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("hit_reduction_cos_max_angle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float hit_reduction_cos_max_angle
     * }
     */
    public static final OfFloat hit_reduction_cos_max_angle$layout() {
        return hit_reduction_cos_max_angle$LAYOUT;
    }

    private static final long hit_reduction_cos_max_angle$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float hit_reduction_cos_max_angle
     * }
     */
    public static final long hit_reduction_cos_max_angle$offset() {
        return hit_reduction_cos_max_angle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float hit_reduction_cos_max_angle
     * }
     */
    public static float hit_reduction_cos_max_angle(MemorySegment struct) {
        return struct.get(hit_reduction_cos_max_angle$LAYOUT, hit_reduction_cos_max_angle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float hit_reduction_cos_max_angle
     * }
     */
    public static void hit_reduction_cos_max_angle(MemorySegment struct, float fieldValue) {
        struct.set(hit_reduction_cos_max_angle$LAYOUT, hit_reduction_cos_max_angle$OFFSET, fieldValue);
    }

    private static final OfFloat penetration_recovery_speed$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("penetration_recovery_speed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float penetration_recovery_speed
     * }
     */
    public static final OfFloat penetration_recovery_speed$layout() {
        return penetration_recovery_speed$LAYOUT;
    }

    private static final long penetration_recovery_speed$OFFSET = 132;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float penetration_recovery_speed
     * }
     */
    public static final long penetration_recovery_speed$offset() {
        return penetration_recovery_speed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float penetration_recovery_speed
     * }
     */
    public static float penetration_recovery_speed(MemorySegment struct) {
        return struct.get(penetration_recovery_speed$LAYOUT, penetration_recovery_speed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float penetration_recovery_speed
     * }
     */
    public static void penetration_recovery_speed(MemorySegment struct, float fieldValue) {
        struct.set(penetration_recovery_speed$LAYOUT, penetration_recovery_speed$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

